## Распределенный вычислитель арифметических выражений

## Требования
Пользователь хочет считать арифметические выражения. Он вводит строку 2 + 2 * 2 и хочет получить в ответ 6. Но наши операции сложения и умножения (также деления и вычитания) выполняются "очень-очень" долго. Поэтому вариант, при котором пользователь делает http-запрос и получает в качетсве ответа результат, невозможна. Более того: вычисление каждой такой операции в нашей "альтернативной реальности" занимает "гигантские" вычислительные мощности. Соответственно, каждое действие мы должны уметь выполнять отдельно и масштабировать эту систему можем добавлением вычислительных мощностей в нашу систему в виде новых "машин". Поэтому пользователь, присылая выражение, получает в ответ идентификатор выражения и может с какой-то периодичностью уточнять у сервера "не посчиталость ли выражение"? Если выражение наконец будет вычислено - то он получит результат. Помните, что некоторые части арфиметического выражения можно вычислять параллельно.

Front-end часть

GUI, который можно представить как 4 страницы

Форма ввода арифметического выражения. Пользователь вводит арифметическое выражение и отправляет POST http-запрос с этим выражением на back-end. Примечание: Запросы должны быть идемпотентными. К запросам добавляется уникальный идентификатор. Если пользователь отправляет запрос с идентификатором, который уже отправлялся и был принят к обработке - ответ 200. Возможные варианты ответа:
200. Выражение успешно принято, распаршено и принято к обработке
400. Выражение невалидно
500. Что-то не так на back-end. В качестве ответа нужно возвращать id принятного к выполнению выражения.
Страница со списком выражений в виде списка с выражениями. Каждая запись на странице содержит статус, выражение, дату его создания и дату заверщения вычисления. Страница получает данные GET http-запрсом с back-end-а
Страница со списком операций в виде пар: имя операции + время его выполнения (доступное для редактирования поле). Как уже оговаривалось в условии задачи, наши операции выполняются "как будто бы очень долго". Страница получает данные GET http-запрсом с back-end-а. Пользователь может настроить время выполения операции и сохранить изменения.
Страница со списком вычислительных можностей. Страница получает данные GET http-запросом с сервера в виде пар: имя вычислительного ресурса + выполняемая на нём операция.

Требования:
Оркестратор может перезапускаться без потери состояния. Все выражения храним в СУБД.
Оркестратор должен отслеживать задачи, которые выполняются слишком долго (вычислитель тоже может уйти со связи) и делать их повторно доступными для вычислений.

Back-end часть

Состоит из 2 элементов:

Сервер, который принимает арифметическое выражение, переводит его в набор последовательных задач и обеспечивает порядок их выполнения. Далее будем называть его оркестратором.
Вычислитель, который может получить от оркестратора задачу, выполнить его и вернуть серверу результат. Далее будем называть его агентом.
Оркестратор
Сервер, который имеет следующие endpoint-ы:

Добавление вычисления арифметического выражения.
Получение списка выражений со статусами.
Получение значения выражения по его идентификатору.
Получение списка доступных операций со временем их выполения.
Получение задачи для выполения.
Приём результата обработки данных.

Агент
Демон, который получает выражение для вычисления с сервера, вычисляет его и отправляет на сервер результат выражения. При старте демон запускает несколько горутин, каждая из которых выступает в роли независимого вычислителя. Количество горутин регулируется переменной среды.

## Разворачивание
Для запуска требуется выполнить сначала команду
```
docker compose up -d
```
Потом создать структуру таблиц с помощью скрипта миграции
Потребуется инструмент migrate [source](https://github.com/golang-migrate/migrate)
```
migrate -path ./schema -database "postgres://postgres:postgres@localhost:5432/calculator_db?sslmode=disable" up
```
Для удаления таблиц
```
migrate -path ./schema -database "postgres://postgres:postgres@localhost:5432/calculator_db?sslmode=disable" down
```

## Особенности реализации
В docker compose описано создание системы из 5 контейнеров. 
1) calculator-api. http сервер, принимает запросы от клиента с заданиями и от агентов вычислителей с посчитанными заданиями и heartbeat
2) message-broker. Брокер сообщений RabbitMQ, используется для передачи сообщений агентам-вычислителям.
3) calculator_db. База данных на Postgres. В нее вносится информация о посчитанных выражениях, подвыражениях, которые находятся в процессе рассчета,
пользовательские настройки длительностей операций и региструются heartbeat агентов вычислителей.
4) calculator-agentN. Агент вычислитель, достает подвыражение из очереди и передает рабочему внутри сервиса на вычисление, количество одновременно допустимых
рабочих регулируется переменной среды. В данном примере поднимаются 2 агента.

Сервис api принимает следующие запросы.
1) Запрос на постановку выражения на вычисление.
```
curl --location --request POST 'http://localhost:8080/expression' --header 'Content-Type: application/json' --data '{
    "req_uid": "2",
    "expression": "1/1/2.2/3.3"
}'
```
Допустимы выражения, хотя бы с одним знаком операции, не более 50 символов в длину(регулируется параметром в конфиге), состоящие из
чисел(целые и с плавающей точкой) и знаков операций `+-/*`. Скобки, двойные знаки операций(-*, +-, -+ и так далее) недопустимы, планирую добавить позднее.
req_uid - Это уникальный идентификатор запроса, нужен для того, чтобы если пользователь не получил ответ содержащий созданное для расчета выражение, он мог
повторным запросом его найти. Если под данным uid уже существует выражение, то сервис просто вернет его пользователю
2) Запрос на отображение всех выражений
```
curl --location --request GET 'http://localhost:8080/expression'
```
Выражения могут быть в процессе расчета, рассчитаны с ошибкой(деление на 0), расчитаны без ошибки.
3) Запрос на добавление замедления для той или иной математической операции. Так как мы имитируем нагрузку на вычислителях. Каждую из четырех допустимых
математических операций можно замедлить. Замедление передается в ms. Допустимы значения от 0 до 65535
Если длительность уже зарегистрированна, ее значение будет перезаписано на новое переданное в запросе. По умолчанию замедление 0.
```
curl --location --request POST 'http://localhost:8080/duration' --header 'Content-Type: application/json' --data '{
    "+":5000,
    "-":5000,
    "*":1000,
    "/":10000
}'
```
4) Запрос на возвращение всех Агентов. Возращает список зарегистрированных агентов-вычислителей, с их именем, датой создания и heartbeat.
```
curl --location --request GET 'http://localhost:8080/agent'
```

```

### Особенности организации очереди
В брокере мы создаем 2 очереди, одна для работы, другая для сообщений, которые не получили подтверждения обработки после вычитывания.
Подразумевается следующий сценарий, хотя для данного проекта он выглядит избыточным, так как данная исключительная ситуация покрывается другим сценарием
самовосттановления. Агент вычитал задачу из очереди, обработал ее и пытаясь сохранить ответ получил ошибку. В этом случае он ставит сообщению в очереди Nack,
что приводит к тому, что сообщение попадает в очередь исключений на 20 секунд(параметр задается в конфиге), а затем возвращается в основную очередь. Где может
быть взят любым свободным вычислителем, вычисление будет проведено заново и будет завново предпринята попытка сообщить результат calculator-api. 

### Описание основных сценариев
1) Положительный. Клиент передает выражение. Api разбивает выражение на подвыражения сохраняет в БД. Отправляет подвыражения, которые могут быть посчитаны
независимо в очередь, оттуда они вычитываются агентами, агент отправляет на api информацию о то, что он взял подвыржение в работу. Агенты 
вместе с подвыражениями получают информацию, о том насколько нужно замедлиться. После выполнения вычисления агенты отправляют на api результаты. Если было
подсчитано последнее повыражение выражения, оно меняет статус на подсчитанное и забирает результат последнего подвыражения.
2) Агент не смог сообщить api, что он хочет взять выражение. Выражение возращается в очередь, попадает в очередь исключений и через 20 секунд его снова может
взять какой-то агент. Дополнительно существет процесс на api, который мониторит не взятые выражения раз в N минут(определяется конфигом), поставит подвыражение еще раз.
В этом случае мы получаем дубль в очереди, но такая избыточность, не страшна, как только выражение возьмет, хоть кто-то, следующие попытки взятия буду сразу
отбрасываться вычислителями, еще до начала вычислений.
3) Агент не смог сообщить, что закончил, сообщение вернется в очередь через очередь исключений через 20 сек. Процесс на api, который мониторит не взятые выражения раз в N минут
заодно проверяет зависшие сообщения, он скинет им флаг агента и они как свободные будут перепоставлены в очередь.
4) Агент умер. Процесс, который мониторит heartbeat от агентов, проверка раз в N(конфиг), разрешено молчать M(конфиг), признает агента мертвым и сбросит его
со всех задач в процессе рассчета. Далее процесс из пункта 2, заметит эти задачи и перепоставит в очередь, где их заберут свободные агенты.
5) Api умерло. Запросы от клиента не принимаются. Сразу после старта через N(конфиг) процесс из пункта 2 перепоставит подвыражения.
6) Умерла база. Клиент не может зарегистировать новые задачи.